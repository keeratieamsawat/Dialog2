from flask import Flask, request, jsonify
from flask_sqlalchemy import SQLAlchemy
from flask_jwt_extended import JWTManager, create_access_token, jwt_required, get_jwt_identity
import datetime
import boto3
import smtplib
from email.message import EmailMessage
from botocore.exceptions import ClientError


# Mock database
users = {}
app = Flask(__name__)

dynamodb = boto3.resource('dynamodb')
data_table = dynamodb.Table('DiaLog_Data')
users_table = dynamodb.Table('DiaLog_Users')

class UserClient:
    def __init__(self, user_id):
        self.user_id = user_id

    def search_data(self, attribute):
        try:
            response = users_table.get_item(Key={'userid':self.user_id},
                ProjectionExpression=attribute
            )

            item = response.get('Item')
            if item:
                return item
            else:
                print("Item not found")
        except Exception as e:
            print(f"Error searching data: {e}")
            return None

    def query_by_date_range(self, data_type, start_date, end_date):
        try:
            response = data_table.query(
                KeyConditionExpression=(
                        Key('userid#datatype').eq(f'{self.user_id}#{data_type}') &
                        Key('date').between(f'{start_date}T00:00:00', f'{end_date}T23:59:59')
                ),
                ProjectionExpression="#date, #value",
                ExpressionAttributeNames={'#date': 'date', '#value': 'value'},
                Limit=500
            )
            return response.get('Items', [])
        except Exception as e:
            print(f"Error querying data: {e}")
            return None

# User registration
@app.route('/register', methods=['POST'])
def register():
    data = request.json
    required_fields = [
        'first_name', 'last_name', 'email', 'password', 'confirm_password',
        'gender', 'birthdate', 'country_of_residence', 'emergency_contact',
        'weight', 'height', 'consent'
    ]

    # Check if all required fields are present
    for field in required_fields:
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400

    # Ensure passwords match
    if data['password'] != data['confirm_password']:
        return jsonify({"error": "Passwords do not match."}), 400

    # Ensure consent is given
    if not data.get('consent', False):
        return jsonify({"error": "User must agree to terms and conditions."}), 400

    # Register user
    user_id = len(users) + 1
    users[user_id] = {
        "first_name": data['first_name'],
        "last_name": data['last_name'],
        "email": data['email'],
        "gender": data['gender'],
        "birthdate": data['birthdate'],
        "country_of_residence": data['country_of_residence'],
        "emergency_contact": data['emergency_contact'],
        "weight": data['weight'],
        "height": data['height']
    }
    return jsonify({"message": "User registered successfully!", "user_id": user_id}), 201

# User login endpoint
@app.route('/login', methods=['POST'])
def login():
    data = request.json
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"error": "Email and password required."}), 400

    user = User.query.filter_by(email=email).first()
    if user and user.password == password:  # Hash comparison in production
        access_token = create_access_token(identity=user.id)
        return jsonify({"message": "Login successful", "access_token": access_token}), 200

    return jsonify({"error": "Invalid credentials."}), 401

# Get all users
@app.route('/users', methods=['GET'])
def get_users():
    return jsonify({"users": users}), 200

# Get a specific user by ID
@app.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    user = users.get(user_id)
    if not user:
        return jsonify({"error": "User not found."}), 404
    return jsonify(user), 200

# Extract user data to a downloadable file
@app.route('/users/<int:user_id>/export', methods=['GET'])
def export_user(user_id):
    user = users.get(user_id)
    if not user:
        return jsonify({"error": "User not found."}), 404

    # Create a simple text representation of the user data
    user_data = "\n".join([f"{key}: {value}" for key, value in user.items()])

    # Save to file
    file_path = f"user_{user_id}_data.txt"
    with open(file_path, 'w') as f:
        f.write(user_data)

    return jsonify({"message": "User data exported successfully!", "file": file_path}), 200

# Mock database
patient_conditions = {}

# Add or update diabetic condition data
@app.route('/conditions', methods=['POST'])
def add_conditions():
    data = request.json
    patient_id = data.get("patient_id")
    if not patient_id:
        return jsonify({"error": "Patient ID is required"}), 400
    
    # Add or update the patient's condition data
    patient_conditions[patient_id] = data
    return jsonify({"message": "Patient condition data saved successfully!", "patient_id": patient_id}), 201

# Get diabetic condition data for a specific patient
@app.route('/conditions/<patient_id>', methods=['GET'])
def get_conditions(patient_id):
    data = patient_conditions.get(patient_id)
    if not data:
        return jsonify({"error": "No data found for the specified patient ID"}), 404
    return jsonify(data), 200

# Fetch all patient condition data
@app.route('/conditions', methods=['GET'])
def get_all_conditions():
    return jsonify({"patients": patient_conditions}), 200

@app.route('/graphs', methods=['GET'])
@jwt_required()
def gen_graph():
    data = request.json()
    start = data.get("start")
    end = data.get("end")

    current_user_id = get_jwt_identity()  # Extract user_id from the JWT
    user = UserClient(current_user_id)  # Create a User instance

    start_date = request.args.get('start_date')
    end_date = request.args.get('end_date')

    if not start_date or not end_date:
        return jsonify({"error": "Missing required parameters"}), 400

    data = user.query_data(start_date, end_date)
    if data is None:
        return jsonify({"error": "Failed to query data"}), 500

    return jsonify({"data": data})

@app.route('/alert-doctor', methods=['POST'])
def send_alert(bloodSugarLevel):
    current_user_id = get_jwt_identity()  # Extract user_id from the JWT
    user = User(current_user_id)  # Create a User instance

    firstname = user.search_data('firstName')['firstName']
    lastname = user.search_data('lastName')['lastName']
    doctor_email = user.search_data('doctorEmail')['doctorEmail']
    unit = user.search_data('unit')['unit']

    msg = EmailMessage()
    msg.set_content(f'Your patient, {firstname} {lastname}, has recorded an unsafe blood sugar level of {bloodSugarLevel} {unit}.')

    msg['Subject'] = 'Patient Alert from DiaLog'
    msg['From'] = 'javacakesdialog@gmail.com'
    msg['To'] = doctor_email

    # send the message via our own SMTP server
    server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
    server.login('javacakesdialog@gmail.com', "kwzr qwep klty agqm")
    server.send_message(msg)
    server.quit()


# send notifications accroding to user's personal settings - eg. at a specific time every day


# Questionnaire endpoint to submit responses
@app.route('/questionnaire', methods=['POST'])
@jwt_required()
def submit_questionnaire():
    data = request.json
    current_user_id = get_jwt_identity()  # Extract user ID from the JWT

    # Validate required fields
    required_fields = ['questions', 'answers']
    for field in required_fields:
        if field not in data:
            return jsonify({"error": f"Missing required field: {field}"}), 400

    # Store the questionnaire data in DynamoDB
    try:
        # Store answers in the DiaLog_Data table
        for answer in data['answers']:
            question_id = answer['question_id']
            response = answer['answer']
            timestamp = datetime.datetime.utcnow().isoformat()  # Use UTC timestamp

            item = {
                'userid': current_user_id,
                'datatype': question_id,
                'date': timestamp,
                'value': response
            }
            data_table.put_item(Item=item)
        
        # Send results to the doctor's email
        send_results_to_doctor(current_user_id, data['answers'])
        
        return jsonify({"message": "Questionnaire submitted successfully!"}), 201

    except Exception as e:
        return jsonify({"error": f"Failed to store questionnaire: {e}"}), 500

def get_user_by_patient_id(patient_id):
    try:
        response = users_table.get_item(Key={'userid': patient_id})
        if 'Item' in response:
            user = response['Item']
            return {
                'firstName': user.get('firstName', 'Unknown'),
                'lastName': user.get('lastName', 'Unknown'),
                'doctorEmail': user.get('doctorEmail', 'doctor@example.com'),
            }
        else:
            return {
                'firstName': 'Unknown',
                'lastName': 'Unknown',
                'doctorEmail': 'doctor@example.com',
            }
    except ClientError as e:
        print(f"Error getting user by patient_id {patient_id}: {e}")
        return {'firstName': 'Unknown', 'lastName': 'Unknown', 'doctorEmail': 'doctor@example.com'}

# Helper function to send results to the doctor
def send_results_to_doctor(patient_id, answers):
    user = get_user_by_patient_id(patient_id)
    firstname = user['firstName']
    lastname = user['lastName']
    doctor_email = user['doctorEmail']
    
    # Prepare the email content with all questions and answers
    questionnaire_responses = "\n".join([f"Q{answer['question_id']}: {answer['answer']}" for answer in answers])

    msg = EmailMessage()
    msg.set_content(f'Your patient, {firstname} {lastname}, has submitted the following questionnaire responses:\n\n{questionnaire_responses}')
    msg['Subject'] = 'Patient Questionnaire Responses from DiaLog'
    msg['From'] = 'javacakesdialog@gmail.com'
    msg['To'] = doctor_email

    server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
    server.login('javacakesdialog@gmail.com', "your_email_password")  # Update with a secure method for password management
    server.send_message(msg)
    server.quit()



if __name__ == '__main__':
    app.run(debug=True)
